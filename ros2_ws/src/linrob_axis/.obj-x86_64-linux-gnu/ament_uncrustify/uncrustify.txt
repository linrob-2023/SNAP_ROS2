-- run_test.py: invoking following command in '/home/boschrexroth/ctrlx-automation-sdk/samples-python/SNAP_ROS2/ros2_ws/src/linrob_axis':
 - /opt/ros/humble/bin/ament_uncrustify --xunit-file /home/boschrexroth/ctrlx-automation-sdk/samples-python/SNAP_ROS2/ros2_ws/src/linrob_axis/.obj-x86_64-linux-gnu/test_results/linrob_axis/uncrustify.xunit.xml

Code style divergence in file 'include/linrob_axis/AxisStates.h':

--- include/linrob_axis/AxisStates.h
+++ include/linrob_axis/AxisStates.h.uncrustify
@@ -11,16 +11,16 @@
-enum class AxisState : uint8_t
-{
-  ABORTING = 0U,
-  CONTINUOUS_MOTION,
-  COORDINATED_MOTION,
-  DISABLED,
-  DISCRETE_MOTION,
-  ERRORSTOP,
-  GANTRY_SLAVE,
-  HOMING,
-  STANDSTILL,
-  STANDSTILL_PENDING,
-  STOPPING,
-  SYNCHRONIZED_MOTION,
-  STOPPED
-};
+  enum class AxisState: uint8_t
+  {
+    ABORTING = 0U,
+    CONTINUOUS_MOTION,
+    COORDINATED_MOTION,
+    DISABLED,
+    DISCRETE_MOTION,
+    ERRORSTOP,
+    GANTRY_SLAVE,
+    HOMING,
+    STANDSTILL,
+    STANDSTILL_PENDING,
+    STOPPING,
+    SYNCHRONIZED_MOTION,
+    STOPPED
+  };

Code style divergence in file 'include/linrob_axis/Connection.h':

--- include/linrob_axis/Connection.h
+++ include/linrob_axis/Connection.h.uncrustify
@@ -14,13 +14,14 @@
-struct Connection
-{
-  /// IP address.
-  std::string ip;
-  /// Username.
-  std::string user;
-  /// Password.
-  std::string password;
-  /// SSL port.
-  int sslPort;
-  /// Data layer nodes addresses.
-  std::unordered_map<std::string, std::pair<std::string, comm::datalayer::Variant> > datalayerNodeMap;
-};
+  struct Connection
+  {
+    /// IP address.
+    std::string ip;
+    /// Username.
+    std::string user;
+    /// Password.
+    std::string password;
+    /// SSL port.
+    int sslPort;
+    /// Data layer nodes addresses.
+    std::unordered_map < std::string, std::pair < std::string,
+    comm::datalayer::Variant >> datalayerNodeMap;
+  };

Code style divergence in file 'include/linrob_axis/Mode.h':

--- include/linrob_axis/Mode.h
+++ include/linrob_axis/Mode.h.uncrustify
@@ -11,6 +11,6 @@
-enum class Mode : uint8_t
-{
-  MANUAL = 0U,
-  AUTO,
-  AUTO_EXTERNAL
-};
+  enum class Mode: uint8_t
+  {
+    MANUAL = 0U,
+    AUTO,
+    AUTO_EXTERNAL
+  };

Code style divergence in file 'include/linrob_axis/PositionSettings.h':

--- include/linrob_axis/PositionSettings.h
+++ include/linrob_axis/PositionSettings.h.uncrustify
@@ -10,13 +10,13 @@
-struct PositionSettings
-{
-  /// Initial position index.
-  uint16_t initialIndex;
-  /// Index where next position will be written in PLC.
-  uint16_t nextPositionIndex;
-  /// Max index value for next position before it will be restored to initial index.
-  uint16_t maxPositionIndices;
-  /// Number of new positions received.
-  uint32_t newPositionsReceivedCount;
-  /// Value at which command to PLC will be sent to execute movements.
-  uint16_t executeMovementsOnIndex;
-};
+  struct PositionSettings
+  {
+    /// Initial position index.
+    uint16_t initialIndex;
+    /// Index where next position will be written in PLC.
+    uint16_t nextPositionIndex;
+    /// Max index value for next position before it will be restored to initial index.
+    uint16_t maxPositionIndices;
+    /// Number of new positions received.
+    uint32_t newPositionsReceivedCount;
+    /// Value at which command to PLC will be sent to execute movements.
+    uint16_t executeMovementsOnIndex;
+  };

Code style divergence in file 'include/linrob_axis/Resource.h':

--- include/linrob_axis/Resource.h
+++ include/linrob_axis/Resource.h.uncrustify
@@ -23,2 +23,2 @@
-class Resource : public hardware_interface::SystemInterface
-{
+  class Resource: public hardware_interface::SystemInterface
+  {
@@ -26,85 +26,95 @@
-  /**
-   * Constructor.
-   */
-  Resource() = default;
-
-  /**
-   * Destructor.
-   */
-  ~Resource() override;
-
-  /**
-   * Initialization of the hardware interface from data parsed from the robot's URDF.
-   * @param info structure with data from URDF.
-   * @return State of the function.
-   */
-  hardware_interface::CallbackReturn on_init(const hardware_interface::HardwareInfo& info) override;
-
-  /**
-   * Callback function for configure transition.
-   * @param previous_state previous state of the hardware interface.
-   * @return state of the function.
-   */
-  hardware_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State& previous_state) override;
-
-  /**
-   * Function for activating the hardware.AxisState
-   * @param previous_state previous state of the hardware interface.
-   * @return state of the function.
-   */
-  hardware_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State& previous_state) override;
-
-  /**
-   * Function for turning off the hardware.
-   * @param previous_state previous state of the hardware interface.
-   * @return state of the function.
-   */
-  hardware_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State& previous_state) override;
-
-  /**
-   * Function for writing latest command to the hardware.
-   * @param time time at the start of this control loop iteration.
-   * @param period measured time taken by the last control loop iteration.
-   * @return state of the function.
-   */
-  hardware_interface::return_type write(const rclcpp::Time& time, const rclcpp::Duration& period) override;
-
-  /**
-   * Function for reading the current state of the hardware.
-   * @param time time at the start of this control loop iteration.
-   * @param period measured time taken by the last control loop iteration.
-   * @return state of the function.
-   */
-  hardware_interface::return_type read(const rclcpp::Time& time, const rclcpp::Duration& period) override;
-
-  /**
-   * Disconnects the datalayer client
-   * @return state of the function.
-   */
-  void disconnect();
-
-  /**
-   * Exports all state interfaces for this hardware interface.
-   * @return vector of state interfaces.
-   */
-  std::vector<hardware_interface::StateInterface> export_state_interfaces() override;
-
-  /**
-   * Exports all command interfaces for this hardware interface.
-   * @return vector of command interfaces.
-   */
-  std::vector<hardware_interface::CommandInterface> export_command_interfaces() override;
-
-  /**
-   * Waits for the system mode to reach the expected mode within a timeout.
-   * Returns SUCCESS if reached, FAILURE on timeout.
-   */
-  hardware_interface::CallbackReturn waitForSystemMode(const std::string& expectedMode, std::chrono::milliseconds timeout);
-
-  // Error code indicating Data Layer connection loss
-  static constexpr uint32_t kConnectionLostErrorCode = 0x090F9000;
-
-  /**
-   * Interval between reconnection attempts when the connection to the Data Layer is lost.
-   */
-  static constexpr std::chrono::seconds kReconnectInterval{5};
+    /**
+     * Constructor.
+     */
+    Resource() = default;
+
+    /**
+     * Destructor.
+     */
+    ~Resource() override;
+
+    /**
+     * Initialization of the hardware interface from data parsed from the robot's URDF.
+     * @param info structure with data from URDF.
+     * @return State of the function.
+     */
+    hardware_interface::CallbackReturn on_init(const hardware_interface::HardwareInfo & info)
+    override;
+
+    /**
+     * Callback function for configure transition.
+     * @param previous_state previous state of the hardware interface.
+     * @return state of the function.
+     */
+    hardware_interface::CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state)
+    override;
+
+    /**
+     * Function for activating the hardware.AxisState
+     * @param previous_state previous state of the hardware interface.
+     * @return state of the function.
+     */
+    hardware_interface::CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state)
+    override;
+
+    /**
+     * Function for turning off the hardware.
+     * @param previous_state previous state of the hardware interface.
+     * @return state of the function.
+     */
+    hardware_interface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state)
+    override;
+
+    /**
+     * Function for writing latest command to the hardware.
+     * @param time time at the start of this control loop iteration.
+     * @param period measured time taken by the last control loop iteration.
+     * @return state of the function.
+     */
+    hardware_interface::return_type write(
+      const rclcpp::Time & time,
+      const rclcpp::Duration & period) override;
+
+    /**
+     * Function for reading the current state of the hardware.
+     * @param time time at the start of this control loop iteration.
+     * @param period measured time taken by the last control loop iteration.
+     * @return state of the function.
+     */
+    hardware_interface::return_type read(
+      const rclcpp::Time & time,
+      const rclcpp::Duration & period) override;
+
+    /**
+     * Disconnects the datalayer client
+     * @return state of the function.
+     */
+    void disconnect();
+
+    /**
+     * Exports all state interfaces for this hardware interface.
+     * @return vector of state interfaces.
+     */
+    std::vector < hardware_interface::StateInterface > export_state_interfaces() override;
+
+    /**
+     * Exports all command interfaces for this hardware interface.
+     * @return vector of command interfaces.
+     */
+    std::vector < hardware_interface::CommandInterface > export_command_interfaces() override;
+
+    /**
+     * Waits for the system mode to reach the expected mode within a timeout.
+     * Returns SUCCESS if reached, FAILURE on timeout.
+     */
+    hardware_interface::CallbackReturn waitForSystemMode(
+      const std::string & expectedMode,
+      std::chrono::milliseconds timeout);
+
+    // Error code indicating Data Layer connection loss
+    static constexpr uint32_t kConnectionLostErrorCode = 0x090F9000;
+
+    /**
+     * Interval between reconnection attempts when the connection to the Data Layer is lost.
+     */
+    static constexpr std::chrono::seconds kReconnectInterval {5};
@@ -113,113 +123,115 @@
-  /**
-   * Creates data pair with datalayer node address and variant type for storing data read from datalayer node and stores
-   * created pair in the map at specified key.
-   * @param key key for the datalayer node.
-   * @param address address of the datalayer node.
-   */
-  void registerDatalayerNode(const std::string& key, const std::string& address);
-
-  /**
-   * Reads datalayer node.
-   * @param key key for the datalayer node.
-   * @param expectedType expected variant type of the data.
-   * @return true if the data was read successfully, false otherwise.
-   */
-  bool updateDataFromNode(const std::string& key, comm::datalayer::VariantType expectedType);
-
-  /**
-   * Establishes connection to the datalayer node.
-   * @return state of the function.
-   */
-  hardware_interface::CallbackReturn connect();
-
-  /**
-   * Checks if the axis is in the expected state.
-   * @param expectedState expected axis state.
-   * @return state of the function.
-   */
-  hardware_interface::CallbackReturn checkAxisState(AxisState expectedState);
-
-  /**
-   * Checks if the system is in the expected mode.
-   * @param expectedMode expected system mode.
-   * @return state of the function.
-   */
-  hardware_interface::CallbackReturn checkSystemMode(const std::string& expectedMode);
-
-  /**
-   * Updates the state of the axis. Converts data stored in the connection map to the state interface.
-   * Stored data: current position and velocity.
-   * @return state of the function.
-   */
-  void updateState();
-
-  /**
-   * Writes data to the specified datalayer node.
-   * @tparam T type of the data to be written.
-   * @param key key for the datalayer node.
-   * @param value value to be written to the datalayer node.
-   * @return true if the data was written successfully, false otherwise.
-   */
-  template <typename T>
-  bool writeToDatalayerNode(const std::string& key, const T& value);
-
-  /**
-   * Converts data soted in the datalayer Variant object to vector of specified type.
-   * @tparam T type of the data to be converted.
-   * @param data datalayer Variant object.
-   * @return vector of converted data.
-   */
-  template <typename T>
-  std::vector<T> variantDataToVector(const comm::datalayer::Variant& data);
-
-  /**
-   * Waits until state, status and mode datalayer nodes are valid.
-   */
-  void waitUntilRequiredNodesAreValid();
-
-  /**
-   * Sets the log level for the datalayer system.
-   *
-   * Possible log levels:
-   * - DEBUG
-   * - INFO
-   * - WARN
-   * - ERROR
-   * - FATAL
-   *
-   * @param level log level to be set.
-   *
-   */
-  void setLogLevel(const std::string& level);
-
-  /**
-   * Processes virtual commands from the controller
-   */
-  void processVirtualCommands();
-
-  /**
-   * Checks the axis state periodically and updates mAxisReadyForOperation flag.
-   * This is called during read/write operations to monitor when the axis becomes ready.
-   */
-  void checkAxisReadiness();
-
-  /**
-   * Switches the system to AUTO_EXTERNAL mode and waits for confirmation.
-   * @return true if successful, false otherwise
-   */
-  bool switchToAutoExternalMode();
-
-  /**
-   * Gets the latest error code from the PLC.
-   * @return The latest error code as uint32_t.
-   */
-  uint32_t getLatestErrorCode();
-
-  /**
-   * Helper to reset the axis target positions buffer (local only).
-   * Fills the buffer with the current position (rounded to 4 decimal places).
-   */
-  inline void resetAxisTargetPositionsExt() {
-    double pos = std::round(mState.at("position") * 10000.0) / 10000.0;
-    for (size_t i = 0; i < kMaxPositionsExt; ++i) {
-      mAxisTargetPositionsExt[i] = pos * 1000.0; // Convert to mm
+    /**
+     * Creates data pair with datalayer node address and variant type for storing data read from datalayer node and stores
+     * created pair in the map at specified key.
+     * @param key key for the datalayer node.
+     * @param address address of the datalayer node.
+     */
+    void registerDatalayerNode(const std::string & key, const std::string & address);
+
+    /**
+     * Reads datalayer node.
+     * @param key key for the datalayer node.
+     * @param expectedType expected variant type of the data.
+     * @return true if the data was read successfully, false otherwise.
+     */
+    bool updateDataFromNode(const std::string & key, comm::datalayer::VariantType expectedType);
+
+    /**
+     * Establishes connection to the datalayer node.
+     * @return state of the function.
+     */
+    hardware_interface::CallbackReturn connect();
+
+    /**
+     * Checks if the axis is in the expected state.
+     * @param expectedState expected axis state.
+     * @return state of the function.
+     */
+    hardware_interface::CallbackReturn checkAxisState(AxisState expectedState);
+
+    /**
+     * Checks if the system is in the expected mode.
+     * @param expectedMode expected system mode.
+     * @return state of the function.
+     */
+    hardware_interface::CallbackReturn checkSystemMode(const std::string & expectedMode);
+
+    /**
+     * Updates the state of the axis. Converts data stored in the connection map to the state interface.
+     * Stored data: current position and velocity.
+     * @return state of the function.
+     */
+    void updateState();
+
+    /**
+     * Writes data to the specified datalayer node.
+     * @tparam T type of the data to be written.
+     * @param key key for the datalayer node.
+     * @param value value to be written to the datalayer node.
+     * @return true if the data was written successfully, false otherwise.
+     */
+    template < typename T >
+    bool writeToDatalayerNode(const std::string & key, const T & value);
+
+    /**
+     * Converts data soted in the datalayer Variant object to vector of specified type.
+     * @tparam T type of the data to be converted.
+     * @param data datalayer Variant object.
+     * @return vector of converted data.
+     */
+    template < typename T >
+    std::vector < T > variantDataToVector(const comm::datalayer::Variant & data);
+
+    /**
+     * Waits until state, status and mode datalayer nodes are valid.
+     */
+    void waitUntilRequiredNodesAreValid();
+
+    /**
+     * Sets the log level for the datalayer system.
+     *
+     * Possible log levels:
+     * - DEBUG
+     * - INFO
+     * - WARN
+     * - ERROR
+     * - FATAL
+     *
+     * @param level log level to be set.
+     *
+     */
+    void setLogLevel(const std::string & level);
+
+    /**
+     * Processes virtual commands from the controller
+     */
+    void processVirtualCommands();
+
+    /**
+     * Checks the axis state periodically and updates mAxisReadyForOperation flag.
+     * This is called during read/write operations to monitor when the axis becomes ready.
+     */
+    void checkAxisReadiness();
+
+    /**
+     * Switches the system to AUTO_EXTERNAL mode and waits for confirmation.
+     * @return true if successful, false otherwise
+     */
+    bool switchToAutoExternalMode();
+
+    /**
+     * Gets the latest error code from the PLC.
+     * @return The latest error code as uint32_t.
+     */
+    uint32_t getLatestErrorCode();
+
+    /**
+     * Helper to reset the axis target positions buffer (local only).
+     * Fills the buffer with the current position (rounded to 4 decimal places).
+     */
+    inline void resetAxisTargetPositionsExt()
+    {
+      double pos = std::round(mState.at("position") * 10000.0) / 10000.0;
+      for (size_t i = 0; i < kMaxPositionsExt; ++i) {
+        mAxisTargetPositionsExt[i] = pos * 1000.0; // Convert to mm
+      }
@@ -226,0 +239,126 @@
+
+    /**
+     * Helper to reset the axis target position timestamp buffer (local only).
+     * Fills the buffer with zeros.
+     */
+    inline void resetAxisTargetPositionTimestampExt()
+    {
+      for (size_t i = 0; i < kMaxPositionsExt; ++i) {
+        mAxisTargetPositionTimestampExt[i] = 0.0;
+      }
+    }
+
+    /**
+     * Helper to reset PLC buffer and index (writes to PLC).
+     * Fills local buffer with current position, resets index, and writes both to the PLC.
+     */
+    bool resetPlcBufferAndIndex();
+
+    /**
+     * Attempts to (re)establish the Data Layer connection if currently lost.
+     * Returns true if connection has been (re)established successfully.
+     */
+    bool attemptReconnect();
+
+    /**
+     * Ensures an active Data Layer connection. Attempts reconnect if marked lost.
+     * If still unavailable, sets error_code and returns false.
+     * @return true if connection is available for IO operations.
+     */
+    bool ensureConnectionAvailable();
+
+    /// Connection settings.
+    linrob::Connection mConnection;
+
+    /// Datalayer system.
+    comm::datalayer::DatalayerSystem mDatalayerSystem;
+
+    /// Datalayer client.
+    std::unique_ptr < comm::datalayer::IClient > mClient = nullptr;
+
+    /// Hardware state interface.
+    std::unordered_map < std::string,
+    double >
+    mState {{"position", 0.0}, {"velocity", 0.0}, {"error_code", 0.0}, {"axis_ready", 0.0}};
+
+    // Hardware command interface.
+    double mPositionCommand {0.0};
+
+    // Virtual command interfaces
+    double mVirtualResetCommand {0.0};
+    double mVirtualReferenceCommand {0.0};
+    double mVirtualStopCommand {0.0};
+    double mVirtualStartMotionCommand {0.0};
+    double mVirtualTargetPositionCommand {0.0};
+    double mVirtualTargetVelocityCommand {0.0};
+
+    /// Last new position received.
+    double mLastPositionCommand {0.0};
+
+    /// Last time when new position command was received.
+    rclcpp::Time mLastPositionCommandTime;
+
+    /// Last time a buffer entry (new or duplicate) was written to PLC.
+    rclcpp::Time mLastBufferFillTime;
+
+    /// Limit for how many duplicate positions to append after last new target
+    uint32_t mDuplicateAppendLimit {5};
+
+    /// Counter tracking how many duplicates have been appended since the last new target position.
+    uint32_t mDuplicateAppendsSinceLastNew {0};
+
+    /// Position command settings for observing and managing system state.
+    PositionSettings mPositionSettings;
+
+    /// Expected max delay in milliseconds between commands.
+    uint32_t mExpectedDelayBetweenCommandsMs {0U};
+
+    /// Position tolerance in mm for checking if axis reached target position.
+    double mPositionToleranceMm {0.01};
+
+    /// Flag to mark if the movement execution was already stopped.
+    bool mMovementExecutionStopped {true};
+
+    /// Flag to track if the axis is ready for operation (in STANDSTILL state)
+    bool mAxisReadyForOperation {false};
+
+    /// Last time we checked the axis state
+    std::chrono::steady_clock::time_point mLastAxisStateCheck;
+
+    /// Buffer for array write to new_position (ARRAY[LREAL] in PLC).
+    static constexpr size_t kMaxPositionsExt = 1000;
+    double mAxisTargetPositionsExt[kMaxPositionsExt] = {0.0};
+
+    /// Timestamp buffer for target positions (local only).
+    double mAxisTargetPositionTimestampExt[kMaxPositionsExt] = {0.0};
+
+    /// Latest error code from the axis
+    uint32_t mLatestErrorCode {0U};
+    /// Flags to track command execution state
+    bool mResetCommandExecuted {false};
+    bool mReferenceCommandExecuted {false};
+    bool mStopCommandExecuted {false};
+    bool mStartMotionCommandExecuted {false};
+
+    /// Flag indicating current connection loss state.
+    bool mConnectionLost {false};
+    /// Timestamp of last reconnection attempt.
+    std::chrono::steady_clock::time_point mLastReconnectAttempt {};
+  };
+
+  template < typename T >
+  std::vector < T > Resource::variantDataToVector(const comm::datalayer::Variant & data)
+  {
+    auto expectedType = VARIANT_ARRAY_TYPE_MAP.at(typeid(T).name());
+    if (data.getType() != expectedType) {
+      RCLCPP_ERROR(
+        rclcpp::get_logger("linrob"),
+        "Invalid type for data. Expected: %u; Actual: %u",
+        static_cast < unsigned int > (expectedType),
+        static_cast < unsigned int > (data.getType()));
+      return {};
+    }
+    auto size = data.getCount();
+    auto typeData = static_cast < const T * > (static_cast < const void * > (data.getData()));
+    std::vector < T > result(typeData, typeData + size);
+    return result;
@@ -229,7 +367,14 @@
-  /**
-   * Helper to reset the axis target position timestamp buffer (local only).
-   * Fills the buffer with zeros.
-   */
-  inline void resetAxisTargetPositionTimestampExt() {
-    for (size_t i = 0; i < kMaxPositionsExt; ++i) {
-      mAxisTargetPositionTimestampExt[i] = 0.0;
+  template < typename T >
+  bool Resource::writeToDatalayerNode(const std::string & key, const T & value)
+  {
+    auto & data = mConnection.datalayerNodeMap.at(key);
+    data.second.setValue(value);
+    auto writeResult = mClient->writeSync(data.first, &data.second);
+    if (writeResult != DL_OK) {
+      RCLCPP_ERROR(
+        rclcpp::get_logger("linrob"), "Failed to write data at %s. %s",
+        data.first.c_str(), writeResult.toString());
+      mState.at("error_code") = static_cast < double > (kConnectionLostErrorCode);
+      mLatestErrorCode = kConnectionLostErrorCode;
+      mConnectionLost = true;
+      return false;
@@ -236,0 +382 @@
+    return true;
@@ -238,113 +383,0 @@
-
-  /**
-   * Helper to reset PLC buffer and index (writes to PLC).
-   * Fills local buffer with current position, resets index, and writes both to the PLC.
-   */
-  bool resetPlcBufferAndIndex();
-
-  /**
-   * Attempts to (re)establish the Data Layer connection if currently lost.
-   * Returns true if connection has been (re)established successfully.
-   */
-  bool attemptReconnect();
-
-  /**
-   * Ensures an active Data Layer connection. Attempts reconnect if marked lost.
-   * If still unavailable, sets error_code and returns false.
-   * @return true if connection is available for IO operations.
-   */
-  bool ensureConnectionAvailable();
-
-  /// Connection settings.
-  linrob::Connection mConnection;
-
-  /// Datalayer system.
-  comm::datalayer::DatalayerSystem mDatalayerSystem;
-
-  /// Datalayer client.
-  std::unique_ptr<comm::datalayer::IClient> mClient = nullptr;
-
-  /// Hardware state interface.
-  std::unordered_map<std::string, double> mState {{"position", 0.0}, {"velocity", 0.0}, {"error_code", 0.0}, {"axis_ready", 0.0}};
-
-  // Hardware command interface.
-  double mPositionCommand {0.0};
-
-  // Virtual command interfaces
-  double mVirtualResetCommand {0.0};
-  double mVirtualReferenceCommand {0.0};
-  double mVirtualStopCommand {0.0};
-  double mVirtualStartMotionCommand {0.0};
-  double mVirtualTargetPositionCommand {0.0};
-  double mVirtualTargetVelocityCommand {0.0};
-
-  /// Last new position received.
-  double mLastPositionCommand {0.0};
-
-  /// Last time when new position command was received.
-  rclcpp::Time mLastPositionCommandTime;
-
-  /// Last time a buffer entry (new or duplicate) was written to PLC.
-  rclcpp::Time mLastBufferFillTime;
-
-  /// Limit for how many duplicate positions to append after last new target
-  uint32_t mDuplicateAppendLimit {5};
-
-  /// Counter tracking how many duplicates have been appended since the last new target position.
-  uint32_t mDuplicateAppendsSinceLastNew {0};
-
-  /// Position command settings for observing and managing system state.
-  PositionSettings mPositionSettings;
-
-  /// Expected max delay in milliseconds between commands.
-  uint32_t mExpectedDelayBetweenCommandsMs {0U};
-
-  /// Position tolerance in mm for checking if axis reached target position.
-  double mPositionToleranceMm {0.01};
-
-  /// Flag to mark if the movement execution was already stopped.
-  bool mMovementExecutionStopped {true};
-
-  /// Flag to track if the axis is ready for operation (in STANDSTILL state)
-  bool mAxisReadyForOperation {false};
-
-  /// Last time we checked the axis state
-  std::chrono::steady_clock::time_point mLastAxisStateCheck;
-
-  /// Buffer for array write to new_position (ARRAY[LREAL] in PLC).
-  static constexpr size_t kMaxPositionsExt = 1000;
-  double mAxisTargetPositionsExt[kMaxPositionsExt] = {0.0};
-
-  /// Timestamp buffer for target positions (local only).
-  double mAxisTargetPositionTimestampExt[kMaxPositionsExt] = {0.0};
-
-  /// Latest error code from the axis
-  uint32_t mLatestErrorCode {0U};
-  /// Flags to track command execution state
-  bool mResetCommandExecuted {false};
-  bool mReferenceCommandExecuted {false};
-  bool mStopCommandExecuted {false};
-  bool mStartMotionCommandExecuted {false};
-
-  /// Flag indicating current connection loss state.
-  bool mConnectionLost {false};
-  /// Timestamp of last reconnection attempt.
-  std::chrono::steady_clock::time_point mLastReconnectAttempt {};
-};
-
-template <typename T>
-std::vector<T> Resource::variantDataToVector(const comm::datalayer::Variant& data)
-{
-  auto expectedType = VARIANT_ARRAY_TYPE_MAP.at(typeid(T).name());
-  if (data.getType() != expectedType)
-  {
-    RCLCPP_ERROR(rclcpp::get_logger("linrob"),
-                 "Invalid type for data. Expected: %u; Actual: %u",
-                 static_cast<unsigned int>(expectedType),
-                 static_cast<unsigned int>(data.getType()));
-    return {};
-  }
-  auto size = data.getCount();
-  auto typeData = static_cast<const T*>(static_cast<const void*>(data.getData()));
-  std::vector<T> result(typeData, typeData + size);
-  return result;
@@ -353,19 +385,0 @@
-template <typename T>
-bool Resource::writeToDatalayerNode(const std::string& key, const T& value)
-{
-  auto& data = mConnection.datalayerNodeMap.at(key);
-  data.second.setValue(value);
-  auto writeResult = mClient->writeSync(data.first, &data.second);
-  if (writeResult != DL_OK)
-  {
-    RCLCPP_ERROR(
-      rclcpp::get_logger("linrob"), "Failed to write data at %s. %s", data.first.c_str(), writeResult.toString());
-    mState.at("error_code") = static_cast<double>(kConnectionLostErrorCode);
-    mLatestErrorCode = kConnectionLostErrorCode;
-    mConnectionLost = true;
-    return false;
-  }
-  return true;
-}
-}
-

Code style divergence in file 'include/linrob_axis/VariantType.h':

--- include/linrob_axis/VariantType.h
+++ include/linrob_axis/VariantType.h.uncrustify
@@ -10,3 +10,4 @@
-const std::unordered_map<std::string, comm::datalayer::VariantType> VARIANT_ARRAY_TYPE_MAP = {
-  {typeid(int).name(), comm::datalayer::VariantType::ARRAY_OF_INT32},
-  {typeid(float).name(), comm::datalayer::VariantType::ARRAY_OF_FLOAT64}};
+  const std::unordered_map < std::string, comm::datalayer::VariantType > VARIANT_ARRAY_TYPE_MAP = {
+    {typeid(int).name(), comm::datalayer::VariantType::ARRAY_OF_INT32},
+    {typeid(float).name(), comm::datalayer::VariantType::ARRAY_OF_FLOAT64}
+  };

Code style divergence in file 'include/linrob_axis/axis_controller.hpp':

--- include/linrob_axis/axis_controller.hpp
+++ include/linrob_axis/axis_controller.hpp.uncrustify
@@ -29 +29 @@
-    const rclcpp::Time& time, const rclcpp::Duration& period) override;
+    const rclcpp::Time & time, const rclcpp::Duration & period) override;
@@ -33 +33 @@
-    const rclcpp_lifecycle::State& previous_state) override;
+    const rclcpp_lifecycle::State & previous_state) override;
@@ -35 +35 @@
-    const rclcpp_lifecycle::State& previous_state) override;
+    const rclcpp_lifecycle::State & previous_state) override;
@@ -37 +37 @@
-    const rclcpp_lifecycle::State& previous_state) override;
+    const rclcpp_lifecycle::State & previous_state) override;

Code style divergence in file 'include/linrob_axis/ctrlx_datalayer_helper.h':

--- include/linrob_axis/ctrlx_datalayer_helper.h
+++ include/linrob_axis/ctrlx_datalayer_helper.h.uncrustify
@@ -10 +10 @@
- /*! \file
+/*! \file
@@ -56,2 +56,2 @@
-  //! Retrieve environment variable SNAP
-static const char* snapPath()
+//! Retrieve environment variable SNAP
+static const char * snapPath()
@@ -75,3 +75,3 @@
-  const std::string& ip = "192.168.1.1",
-  const std::string& user = "boschrexroth",
-  const std::string& password = "boschrexroth",
+  const std::string & ip = "192.168.1.1",
+  const std::string & user = "boschrexroth",
+  const std::string & password = "boschrexroth",
@@ -80,2 +80 @@
-  if (isSnap())
-  {
+  if (isSnap()) {
@@ -85 +84,2 @@
-  std::string connectionString = DL_TCP + user + std::string(":") + password + std::string("@") + ip;
+  std::string connectionString = DL_TCP + user + std::string(":") + password + std::string("@") +
+    ip;
@@ -87,2 +87 @@
-  if (443 == sslPort)
-  {
+  if (443 == sslPort) {
@@ -102,4 +101,5 @@
-inline comm::datalayer::IClient3* getClient(comm::datalayer::DatalayerSystem& datalayerSystem,
-                                           const std::string& ip = "192.168.1.1",
-                                           const std::string& user = "boschrexroth",
-                                           const std::string& password = "boschrexroth", int sslPort = 443)
+inline comm::datalayer::IClient3 * getClient(
+  comm::datalayer::DatalayerSystem & datalayerSystem,
+  const std::string & ip = "192.168.1.1",
+  const std::string & user = "boschrexroth",
+  const std::string & password = "boschrexroth", int sslPort = 443)
@@ -108,3 +108,2 @@
-  comm::datalayer::IClient3* client = datalayerSystem.factory()->createClient3(connectionString);
-  if (client->isConnected())
-  {
+  comm::datalayer::IClient3 * client = datalayerSystem.factory()->createClient3(connectionString);
+  if (client->isConnected()) {
@@ -126,4 +125,5 @@
-inline comm::datalayer::IProvider3* getProvider(comm::datalayer::DatalayerSystem& datalayerSystem,
-                                               const std::string& ip = "192.168.1.1",
-                                               const std::string& user = "boschrexroth",
-                                               const std::string& password = "boschrexroth", int sslPort = 443)
+inline comm::datalayer::IProvider3 * getProvider(
+  comm::datalayer::DatalayerSystem & datalayerSystem,
+  const std::string & ip = "192.168.1.1",
+  const std::string & user = "boschrexroth",
+  const std::string & password = "boschrexroth", int sslPort = 443)
@@ -132,3 +132,3 @@
-  comm::datalayer::IProvider3* provider = datalayerSystem.factory4()->createProvider3(connectionString);
-  if (provider->start() == DL_OK)
-  {
+  comm::datalayer::IProvider3 * provider = datalayerSystem.factory4()->createProvider3(
+    connectionString);
+  if (provider->start() == DL_OK) {

Code style divergence in file 'src/Resource.cpp':

--- src/Resource.cpp
+++ src/Resource.cpp.uncrustify
@@ -27 +27 @@
-hardware_interface::CallbackReturn Resource::on_init(const hardware_interface::HardwareInfo& info)
+hardware_interface::CallbackReturn Resource::on_init(const hardware_interface::HardwareInfo & info)
@@ -31 +31,2 @@
-  if (hardware_interface::SystemInterface::on_init(info) != hardware_interface::CallbackReturn::SUCCESS)
+  if (hardware_interface::SystemInterface::on_init(info) !=
+    hardware_interface::CallbackReturn::SUCCESS)
@@ -37 +38 @@
-  const auto& params = info.hardware_parameters;
+  const auto & params = info.hardware_parameters;
@@ -66 +67,2 @@
-  mPositionSettings.initialIndex = static_cast<uint16_t>(std::stoi(params.at("initial_position_index")));
+  mPositionSettings.initialIndex =
+    static_cast<uint16_t>(std::stoi(params.at("initial_position_index")));
@@ -68 +70,2 @@
-  mPositionSettings.maxPositionIndices = static_cast<uint16_t>(std::stoi(params.at("max_position_indices")));
+  mPositionSettings.maxPositionIndices =
+    static_cast<uint16_t>(std::stoi(params.at("max_position_indices")));
@@ -73 +76,2 @@
-  mExpectedDelayBetweenCommandsMs = static_cast<uint32_t>(1000.F / std::stof(params.at("update_frequency_hz")));
+  mExpectedDelayBetweenCommandsMs =
+    static_cast<uint32_t>(1000.F / std::stof(params.at("update_frequency_hz")));
@@ -94 +98 @@
-hardware_interface::CallbackReturn Resource::on_configure(const rclcpp_lifecycle::State&)
+hardware_interface::CallbackReturn Resource::on_configure(const rclcpp_lifecycle::State &)
@@ -98,2 +102 @@
-  if (connectionResult != hardware_interface::CallbackReturn::SUCCESS)
-  {
+  if (connectionResult != hardware_interface::CallbackReturn::SUCCESS) {
@@ -106 +109 @@
-hardware_interface::CallbackReturn Resource::on_activate(const rclcpp_lifecycle::State&)
+hardware_interface::CallbackReturn Resource::on_activate(const rclcpp_lifecycle::State &)
@@ -114 +117,3 @@
-    RCLCPP_INFO(rclcpp::get_logger(LINROB), "Axis is in STANDSTILL state - proceeding with full activation");
+    RCLCPP_INFO(
+      rclcpp::get_logger(
+        LINROB), "Axis is in STANDSTILL state - proceeding with full activation");
@@ -121,2 +126 @@
-    if (!resetResult)
-    {
+    if (!resetResult) {
@@ -136,2 +140,3 @@
-  RCLCPP_INFO(rclcpp::get_logger(LINROB), "Resource activation FINISHED. Axis ready for operation: %s",
-             mAxisReadyForOperation ? "YES" : "NO");
+  RCLCPP_INFO(
+    rclcpp::get_logger(LINROB), "Resource activation FINISHED. Axis ready for operation: %s",
+    mAxisReadyForOperation ? "YES" : "NO");
@@ -141 +146 @@
-hardware_interface::CallbackReturn Resource::on_deactivate(const rclcpp_lifecycle::State&)
+hardware_interface::CallbackReturn Resource::on_deactivate(const rclcpp_lifecycle::State &)
@@ -146,2 +151 @@
-  if (axisStateResult != hardware_interface::CallbackReturn::SUCCESS)
-  {
+  if (axisStateResult != hardware_interface::CallbackReturn::SUCCESS) {
@@ -149,3 +153,4 @@
-    if (axisStateResult != hardware_interface::CallbackReturn::SUCCESS)
-    {
-      RCLCPP_ERROR(rclcpp::get_logger(LINROB), "Axis is not in STANDSTILL or STOPPED state during deactivation");
+    if (axisStateResult != hardware_interface::CallbackReturn::SUCCESS) {
+      RCLCPP_ERROR(
+        rclcpp::get_logger(
+          LINROB), "Axis is not in STANDSTILL or STOPPED state during deactivation");
@@ -157,2 +162 @@
-  if (!setSystemModeResult)
-  {
+  if (!setSystemModeResult) {
@@ -162 +166,3 @@
-  RCLCPP_INFO(rclcpp::get_logger(LINROB), "Waiting %ld seconds for PLC to change operation mode...", kSetModeSleep.count());
+  RCLCPP_INFO(
+    rclcpp::get_logger(
+      LINROB), "Waiting %ld seconds for PLC to change operation mode...", kSetModeSleep.count());
@@ -166,2 +172 @@
-  if (systemModeResult != hardware_interface::CallbackReturn::SUCCESS)
-  {
+  if (systemModeResult != hardware_interface::CallbackReturn::SUCCESS) {
@@ -174,2 +179 @@
-  if (!writeResult)
-  {
+  if (!writeResult) {
@@ -186,2 +190 @@
-  if (mClient)
-  {
+  if (mClient) {
@@ -193 +196 @@
-hardware_interface::return_type Resource::write(const rclcpp::Time& time, const rclcpp::Duration&)
+hardware_interface::return_type Resource::write(const rclcpp::Time & time, const rclcpp::Duration &)
@@ -203,2 +206 @@
-  if (!mAxisReadyForOperation)
-  {
+  if (!mAxisReadyForOperation) {
@@ -206,2 +208 @@
-    if (!mAxisReadyForOperation)
-    {
+    if (!mAxisReadyForOperation) {
@@ -214,2 +215,36 @@
-    if (mDuplicateAppendsSinceLastNew >= mDuplicateAppendLimit) {
-      RCLCPP_DEBUG(rclcpp::get_logger(LINROB), "Duplicate append limit (%u) reached, not appending further targets", mDuplicateAppendLimit);
+      if (mDuplicateAppendsSinceLastNew >= mDuplicateAppendLimit) {
+        RCLCPP_DEBUG(
+          rclcpp::get_logger(
+            LINROB), "Duplicate append limit (%u) reached, not appending further targets",
+          mDuplicateAppendLimit);
+        return true;
+      }
+      if (mPositionSettings.nextPositionIndex == kMaxPositionsExt) {
+        mPositionSettings.nextPositionIndex = 1;
+      } else {
+        ++mPositionSettings.nextPositionIndex;
+      }
+
+      size_t pos = mPositionSettings.nextPositionIndex - 1;
+      if (pos >= kMaxPositionsExt) {pos = 0;}
+
+      mAxisTargetPositionsExt[pos] = target * 1000.0; // Convert to mm
+      mAxisTargetPositionTimestampExt[pos] = 20.0;
+
+      if (!writeToDatalayerNode("new_position", mAxisTargetPositionsExt)) {
+        return false;
+      }
+      if (!writeToDatalayerNode("new_position_timestamp", mAxisTargetPositionTimestampExt)) {
+        return false;
+      }
+      if (!writeToDatalayerNode("next_pos_index", mPositionSettings.nextPositionIndex)) {
+        return false;
+      }
+      mLastBufferFillTime = time;
+      if (mDuplicateAppendsSinceLastNew < UINT32_MAX) {
+        ++mDuplicateAppendsSinceLastNew;
+      }
+      RCLCPP_DEBUG(
+        rclcpp::get_logger(
+          LINROB), "Buffered duplicate target %.8f mm at index %u", mLastPositionCommand,
+        mPositionSettings.nextPositionIndex);
@@ -217,25 +252 @@
-    }
-    if (mPositionSettings.nextPositionIndex == kMaxPositionsExt)
-      mPositionSettings.nextPositionIndex = 1;
-    else
-      ++mPositionSettings.nextPositionIndex;
-
-    size_t pos = mPositionSettings.nextPositionIndex - 1;
-    if (pos >= kMaxPositionsExt) pos = 0;
-
-    mAxisTargetPositionsExt[pos] = target * 1000.0; // Convert to mm
-    mAxisTargetPositionTimestampExt[pos] = 20.0;
-
-    if (!writeToDatalayerNode("new_position", mAxisTargetPositionsExt))
-      return false;
-    if (!writeToDatalayerNode("new_position_timestamp", mAxisTargetPositionTimestampExt))
-      return false;
-    if (!writeToDatalayerNode("next_pos_index", mPositionSettings.nextPositionIndex))
-      return false;
-    mLastBufferFillTime = time;
-    if (mDuplicateAppendsSinceLastNew < UINT32_MAX) {
-      ++mDuplicateAppendsSinceLastNew;
-    }
-    RCLCPP_DEBUG(rclcpp::get_logger(LINROB), "Buffered duplicate target %.8f mm at index %u", mLastPositionCommand, mPositionSettings.nextPositionIndex);
-    return true;
-  };
+    };
@@ -250,2 +261 @@
-  if (!receivedNewTarget)
-  {
+  if (!receivedNewTarget) {
@@ -253,2 +263 @@
-    if (mPositionSettings.newPositionsReceivedCount > 0 && !mMovementExecutionStopped)
-    {
+    if (mPositionSettings.newPositionsReceivedCount > 0 && !mMovementExecutionStopped) {
@@ -256,2 +265,4 @@
-      auto expectedDurationBetweenCommands = rclcpp::Duration(std::chrono::milliseconds(mExpectedDelayBetweenCommandsMs));
-      bool timeToRefill = (mLastBufferFillTime.nanoseconds() == 0) || (time - mLastBufferFillTime >= expectedDurationBetweenCommands);
+      auto expectedDurationBetweenCommands =
+        rclcpp::Duration(std::chrono::milliseconds(mExpectedDelayBetweenCommandsMs));
+      bool timeToRefill = (mLastBufferFillTime.nanoseconds() == 0) ||
+        (time - mLastBufferFillTime >= expectedDurationBetweenCommands);
@@ -260,3 +271,2 @@
-      if (timeToRefill)
-      {
-        if (!updateDataFromNode("status", comm::datalayer::VariantType::ARRAY_OF_INT32))
+      if (timeToRefill) {
+        if (!updateDataFromNode("status", comm::datalayer::VariantType::ARRAY_OF_INT32)) {
@@ -264 +274,2 @@
-        auto& statusData = mConnection.datalayerNodeMap.at("status");
+        }
+        auto & statusData = mConnection.datalayerNodeMap.at("status");
@@ -269,5 +280,7 @@
-        RCLCPP_DEBUG(rclcpp::get_logger(LINROB),
-                     "(Buffering) Target %.8f mm tol %.8f mm current %.8f error %.8f state %u", mLastPositionCommand, mPositionToleranceMm, currentPosition, positionError, static_cast<unsigned int>(axisStatus));
-
-        if (positionError <= mPositionToleranceMm)
-        {
+        RCLCPP_DEBUG(
+          rclcpp::get_logger(
+            LINROB),
+          "(Buffering) Target %.8f mm tol %.8f mm current %.8f error %.8f state %u", mLastPositionCommand, mPositionToleranceMm, currentPosition, positionError,
+          static_cast<unsigned int>(axisStatus));
+
+        if (positionError <= mPositionToleranceMm) {
@@ -276 +289 @@
-          if (!writeToDatalayerNode("execute_movements", false))
+          if (!writeToDatalayerNode("execute_movements", false)) {
@@ -277,0 +291 @@
+          }
@@ -279,3 +293,5 @@
-          RCLCPP_INFO(rclcpp::get_logger(LINROB),
-                      "Movement execution stopped. Axis reached target %.8f mm (tolerance %.8f mm). Arrays reset.",
-                      mLastPositionCommand, mPositionToleranceMm);
+          RCLCPP_INFO(
+            rclcpp::get_logger(
+              LINROB),
+            "Movement execution stopped. Axis reached target %.8f mm (tolerance %.8f mm). Arrays reset.",
+            mLastPositionCommand, mPositionToleranceMm);
@@ -283 +299 @@
-          if (!resetPlcBufferAndIndex())
+          if (!resetPlcBufferAndIndex()) {
@@ -285,3 +301,2 @@
-        }
-        else
-        {
+          }
+        } else {
@@ -289 +304 @@
-          if (!appendDuplicateTarget(mLastPositionCommand))
+          if (!appendDuplicateTarget(mLastPositionCommand)) {
@@ -290,0 +306 @@
+          }
@@ -321 +337 @@
-  if (mPositionSettings.nextPositionIndex == kMaxPositionsExt)
+  if (mPositionSettings.nextPositionIndex == kMaxPositionsExt) {
@@ -323 +339 @@
-  else
+  } else {
@@ -324,0 +341 @@
+  }
@@ -328 +345 @@
-  if (pos >= kMaxPositionsExt) pos = 0;
+  if (pos >= kMaxPositionsExt) {pos = 0;}
@@ -336 +353 @@
-  if (!writeToDatalayerNode("new_position", mAxisTargetPositionsExt))
+  if (!writeToDatalayerNode("new_position", mAxisTargetPositionsExt)) {
@@ -338 +355,2 @@
-  if (!writeToDatalayerNode("new_position_timestamp", mAxisTargetPositionTimestampExt))
+  }
+  if (!writeToDatalayerNode("new_position_timestamp", mAxisTargetPositionTimestampExt)) {
@@ -340 +358,2 @@
-  if (!writeToDatalayerNode("next_pos_index", mPositionSettings.nextPositionIndex))
+  }
+  if (!writeToDatalayerNode("next_pos_index", mPositionSettings.nextPositionIndex)) {
@@ -341,0 +361 @@
+  }
@@ -345,3 +365,2 @@
-  if (mPositionSettings.newPositionsReceivedCount >= mPositionSettings.executeMovementsOnIndex)
-  {
-    if (!writeToDatalayerNode("execute_movements", true))
+  if (mPositionSettings.newPositionsReceivedCount >= mPositionSettings.executeMovementsOnIndex) {
+    if (!writeToDatalayerNode("execute_movements", true)) {
@@ -348,0 +368 @@
+    }
@@ -356 +376 @@
-hardware_interface::return_type Resource::read(const rclcpp::Time&, const rclcpp::Duration&)
+hardware_interface::return_type Resource::read(const rclcpp::Time &, const rclcpp::Duration &)
@@ -362,2 +382 @@
-  if (!mAxisReadyForOperation)
-  {
+  if (!mAxisReadyForOperation) {
@@ -365,2 +384 @@
-    if (!mAxisReadyForOperation)
-    {
+    if (!mAxisReadyForOperation) {
@@ -383,2 +401 @@
-  if (!updateResult)
-  {
+  if (!updateResult) {
@@ -390 +407 @@
-    auto &statusData = mConnection.datalayerNodeMap.at("status");
+    auto & statusData = mConnection.datalayerNodeMap.at("status");
@@ -392,4 +409,2 @@
-    if (axisStatus == AxisState::ERRORSTOP)
-    {
-      if (!mMovementExecutionStopped)
-      {
+    if (axisStatus == AxisState::ERRORSTOP) {
+      if (!mMovementExecutionStopped) {
@@ -397,2 +412 @@
-        if (!writeToDatalayerNode("execute_movements", false))
-        {
+        if (!writeToDatalayerNode("execute_movements", false)) {
@@ -429,2 +443,6 @@
-  command_interfaces.emplace_back("joint_1", "virtual_target_position", &mVirtualTargetPositionCommand);
-  command_interfaces.emplace_back("joint_1", "virtual_target_velocity", &mVirtualTargetVelocityCommand);
+  command_interfaces.emplace_back(
+    "joint_1", "virtual_target_position",
+    &mVirtualTargetPositionCommand);
+  command_interfaces.emplace_back(
+    "joint_1", "virtual_target_velocity",
+    &mVirtualTargetVelocityCommand);
@@ -434,16 +452,22 @@
-hardware_interface::CallbackReturn Resource::waitForSystemMode(const std::string& expectedMode, std::chrono::milliseconds timeout)
-{
-    auto start = std::chrono::steady_clock::now();
-    const std::chrono::milliseconds pollInterval(kStatePollInterval);
-
-    while (std::chrono::steady_clock::now() - start < timeout) {
-        auto result = checkSystemMode(expectedMode);
-        if (result == hardware_interface::CallbackReturn::SUCCESS) {
-            RCLCPP_INFO(rclcpp::get_logger(LINROB), "System reached expected mode: %s", expectedMode.c_str());
-            return result;
-        }
-        RCLCPP_INFO(rclcpp::get_logger(LINROB), "Waiting for system mode '%s'", expectedMode.c_str());
-        std::this_thread::sleep_for(pollInterval);
-    }
-    RCLCPP_ERROR(rclcpp::get_logger(LINROB), "Timeout waiting for system mode '%s'", expectedMode.c_str());
-    return hardware_interface::CallbackReturn::FAILURE;
+hardware_interface::CallbackReturn Resource::waitForSystemMode(
+  const std::string & expectedMode,
+  std::chrono::milliseconds timeout)
+{
+  auto start = std::chrono::steady_clock::now();
+  const std::chrono::milliseconds pollInterval(kStatePollInterval);
+
+  while (std::chrono::steady_clock::now() - start < timeout) {
+    auto result = checkSystemMode(expectedMode);
+    if (result == hardware_interface::CallbackReturn::SUCCESS) {
+      RCLCPP_INFO(
+        rclcpp::get_logger(LINROB), "System reached expected mode: %s",
+        expectedMode.c_str());
+      return result;
+    }
+    RCLCPP_INFO(rclcpp::get_logger(LINROB), "Waiting for system mode '%s'", expectedMode.c_str());
+    std::this_thread::sleep_for(pollInterval);
+  }
+  RCLCPP_ERROR(
+    rclcpp::get_logger(
+      LINROB), "Timeout waiting for system mode '%s'", expectedMode.c_str());
+  return hardware_interface::CallbackReturn::FAILURE;
@@ -456 +480,3 @@
-    getConnectionString(mConnection.ip, mConnection.user, mConnection.password, mConnection.sslPort);
+    getConnectionString(
+    mConnection.ip, mConnection.user, mConnection.password,
+    mConnection.sslPort);
@@ -461,2 +487 @@
-  if (mClient == nullptr)
-  {
+  if (mClient == nullptr) {
@@ -466,2 +491 @@
-  if (!mClient->isConnected())
-  {
+  if (!mClient->isConnected()) {
@@ -478,3 +502,4 @@
-  auto statusUpdateResult = updateDataFromNode("status", comm::datalayer::VariantType::ARRAY_OF_INT32);
-  if (!statusUpdateResult)
-  {
+  auto statusUpdateResult = updateDataFromNode(
+    "status",
+    comm::datalayer::VariantType::ARRAY_OF_INT32);
+  if (!statusUpdateResult) {
@@ -485 +510 @@
-  auto& statusData = mConnection.datalayerNodeMap.at("status");
+  auto & statusData = mConnection.datalayerNodeMap.at("status");
@@ -488,6 +513,6 @@
-  if (axisStatus != expectedState)
-  {
-    RCLCPP_INFO(rclcpp::get_logger(LINROB),
-                "Axis is not in expected state. Expected: %u, Actual: %u",
-                static_cast<unsigned int>(expectedState),
-                static_cast<unsigned int>(axisStatus));
+  if (axisStatus != expectedState) {
+    RCLCPP_INFO(
+      rclcpp::get_logger(LINROB),
+      "Axis is not in expected state. Expected: %u, Actual: %u",
+      static_cast<unsigned int>(expectedState),
+      static_cast<unsigned int>(axisStatus));
@@ -501 +526 @@
-hardware_interface::CallbackReturn Resource::checkSystemMode(const std::string& expectedMode)
+hardware_interface::CallbackReturn Resource::checkSystemMode(const std::string & expectedMode)
@@ -504,2 +529 @@
-  if (!modeUpdateResult)
-  {
+  if (!modeUpdateResult) {
@@ -510 +534 @@
-  const auto& modeData = mConnection.datalayerNodeMap.at("read_mode");
+  const auto & modeData = mConnection.datalayerNodeMap.at("read_mode");
@@ -513,3 +537,4 @@
-  if (mode != expectedMode)
-  {
-    RCLCPP_INFO(rclcpp::get_logger(LINROB), ("System is not in expected mode: " + expectedMode).c_str());
+  if (mode != expectedMode) {
+    RCLCPP_INFO(
+      rclcpp::get_logger(
+        LINROB), ("System is not in expected mode: " + expectedMode).c_str());
@@ -521 +546 @@
-void Resource::registerDatalayerNode(const std::string& key, const std::string& address)
+void Resource::registerDatalayerNode(const std::string & key, const std::string & address)
@@ -526,3 +551,5 @@
-bool Resource::updateDataFromNode(const std::string& key, comm::datalayer::VariantType expectedType)
-{
-  auto& data = mConnection.datalayerNodeMap.at(key);
+bool Resource::updateDataFromNode(
+  const std::string & key,
+  comm::datalayer::VariantType expectedType)
+{
+  auto & data = mConnection.datalayerNodeMap.at(key);
@@ -532,8 +559,12 @@
-  RCLCPP_DEBUG(rclcpp::get_logger(LINROB), "Result is DL_OK %s.", std::to_string(result == DL_OK).c_str());
-  RCLCPP_DEBUG(rclcpp::get_logger(LINROB),
-               "Result type is %u. Expected type is %u.",
-               static_cast<unsigned int>(data.second.getType()),
-               static_cast<unsigned int>(expectedType));
-  if (result != DL_OK)
-  {
-    RCLCPP_ERROR(rclcpp::get_logger(LINROB), "Failed to read data at %s. %s", data.first.c_str(), result.toString());
+  RCLCPP_DEBUG(
+    rclcpp::get_logger(LINROB), "Result is DL_OK %s.", std::to_string(
+      result == DL_OK).c_str());
+  RCLCPP_DEBUG(
+    rclcpp::get_logger(LINROB),
+    "Result type is %u. Expected type is %u.",
+    static_cast<unsigned int>(data.second.getType()),
+    static_cast<unsigned int>(expectedType));
+  if (result != DL_OK) {
+    RCLCPP_ERROR(
+      rclcpp::get_logger(LINROB), "Failed to read data at %s. %s",
+      data.first.c_str(), result.toString());
@@ -546,7 +577,7 @@
-  if (data.second.getType() != expectedType)
-  {
-    RCLCPP_ERROR(rclcpp::get_logger(LINROB),
-                 "Invalid type for data at %s. Expected: %u; Actual: %u",
-                 data.first.c_str(),
-                 static_cast<unsigned int>(expectedType),
-                 static_cast<unsigned int>(data.second.getType()));
+  if (data.second.getType() != expectedType) {
+    RCLCPP_ERROR(
+      rclcpp::get_logger(LINROB),
+      "Invalid type for data at %s. Expected: %u; Actual: %u",
+      data.first.c_str(),
+      static_cast<unsigned int>(expectedType),
+      static_cast<unsigned int>(data.second.getType()));
@@ -562,2 +593,4 @@
-  mState.at("position") = *reinterpret_cast<double*>(mConnection.datalayerNodeMap.at("position").second.getData());
-  mState.at("velocity") = *reinterpret_cast<double*>(mConnection.datalayerNodeMap.at("velocity").second.getData());
+  mState.at("position") =
+    *reinterpret_cast<double *>(mConnection.datalayerNodeMap.at("position").second.getData());
+  mState.at("velocity") =
+    *reinterpret_cast<double *>(mConnection.datalayerNodeMap.at("velocity").second.getData());
@@ -583,2 +616 @@
-  while (wait)
-  {
+  while (wait) {
@@ -594,3 +626,4 @@
-    RCLCPP_DEBUG(rclcpp::get_logger(LINROB),
-                 "Update final result value: %s; If all valid: 1",
-                 std::to_string(updateResult).c_str());
+    RCLCPP_DEBUG(
+      rclcpp::get_logger(LINROB),
+      "Update final result value: %s; If all valid: 1",
+      std::to_string(updateResult).c_str());
@@ -603 +636,2 @@
-bool Resource::resetPlcBufferAndIndex() {
+bool Resource::resetPlcBufferAndIndex()
+{
@@ -608,2 +642,6 @@
-  auto newTimestampWriteResult = writeToDatalayerNode("new_position_timestamp", mAxisTargetPositionTimestampExt);
-  auto nextPosIndexWriteResult = writeToDatalayerNode("next_pos_index", mPositionSettings.nextPositionIndex);
+  auto newTimestampWriteResult = writeToDatalayerNode(
+    "new_position_timestamp",
+    mAxisTargetPositionTimestampExt);
+  auto nextPosIndexWriteResult = writeToDatalayerNode(
+    "next_pos_index",
+    mPositionSettings.nextPositionIndex);
@@ -660 +698 @@
-void Resource::setLogLevel(const std::string& level)
+void Resource::setLogLevel(const std::string & level)
@@ -664,2 +702 @@
-  if (level == "DEBUG")
-  {
+  if (level == "DEBUG") {
@@ -667,3 +704 @@
-  }
-  else if (level == "INFO")
-  {
+  } else if (level == "INFO") {
@@ -671,3 +706 @@
-  }
-  else if (level == "WARN")
-  {
+  } else if (level == "WARN") {
@@ -675,3 +708 @@
-  }
-  else if (level == "ERROR")
-  {
+  } else if (level == "ERROR") {
@@ -679,3 +710 @@
-  }
-  else if (level == "FATAL")
-  {
+  } else if (level == "FATAL") {
@@ -683,3 +712 @@
-  }
-  else
-  {
+  } else {
@@ -695,2 +722 @@
-  if (mVirtualResetCommand > 0.5 && !mResetCommandExecuted)
-  {
+  if (mVirtualResetCommand > 0.5 && !mResetCommandExecuted) {
@@ -698,2 +724 @@
-    if (result)
-    {
+    if (result) {
@@ -702,3 +727 @@
-    }
-    else
-    {
+    } else {
@@ -710,2 +733 @@
-    if (result)
-    {
+    if (result) {
@@ -713,3 +735 @@
-    }
-    else
-    {
+    } else {
@@ -718,3 +738 @@
-  }
-  else if (mVirtualResetCommand <= 0.5)
-  {
+  } else if (mVirtualResetCommand <= 0.5) {
@@ -725,2 +743 @@
-  if (mVirtualReferenceCommand > 0.5 && !mReferenceCommandExecuted)
-  {
+  if (mVirtualReferenceCommand > 0.5 && !mReferenceCommandExecuted) {
@@ -728,2 +745 @@
-    if (result)
-    {
+    if (result) {
@@ -732,3 +748 @@
-    }
-    else
-    {
+    } else {
@@ -737,3 +751 @@
-  }
-  else if (mVirtualReferenceCommand <= 0.5)
-  {
+  } else if (mVirtualReferenceCommand <= 0.5) {
@@ -744,2 +756 @@
-  if (mVirtualStopCommand > 0.5 && !mStopCommandExecuted)
-  {
+  if (mVirtualStopCommand > 0.5 && !mStopCommandExecuted) {
@@ -747,2 +758 @@
-    if (result)
-    {
+    if (result) {
@@ -751,3 +761 @@
-    }
-    else
-    {
+    } else {
@@ -756,3 +764 @@
-  }
-  else if (mVirtualStopCommand <= 0.5)
-  {
+  } else if (mVirtualStopCommand <= 0.5) {
@@ -764,3 +770,3 @@
-      mConnection.datalayerNodeMap.count("virtual_target_position")) {
-    if (mVirtualStartMotionCommand > 0.5 && !mStartMotionCommandExecuted)
-    {
+    mConnection.datalayerNodeMap.count("virtual_target_position"))
+  {
+    if (mVirtualStartMotionCommand > 0.5 && !mStartMotionCommandExecuted) {
@@ -768,2 +774 @@
-      if (result)
-      {
+      if (result) {
@@ -772,3 +777 @@
-      }
-      else
-      {
+      } else {
@@ -777,3 +780 @@
-    }
-    else if (mVirtualStartMotionCommand <= 0.5)
-    {
+    } else if (mVirtualStartMotionCommand <= 0.5) {
@@ -801,4 +802,3 @@
-  auto& errorData = mConnection.datalayerNodeMap.at("error_code");
-  if (errorData.second.getType() == comm::datalayer::VariantType::UINT32)
-  {
-    mLatestErrorCode = *reinterpret_cast<uint32_t*>(errorData.second.getData());
+  auto & errorData = mConnection.datalayerNodeMap.at("error_code");
+  if (errorData.second.getType() == comm::datalayer::VariantType::UINT32) {
+    mLatestErrorCode = *reinterpret_cast<uint32_t *>(errorData.second.getData());
@@ -812 +812,2 @@
-  auto setSystemModeResult = writeToDatalayerNode("set_mode", static_cast<uint8_t>(Mode::AUTO_EXTERNAL));
+  auto setSystemModeResult =
+    writeToDatalayerNode("set_mode", static_cast<uint8_t>(Mode::AUTO_EXTERNAL));
@@ -818 +819,3 @@
-  RCLCPP_INFO(rclcpp::get_logger(LINROB), "Waiting %ld seconds for PLC to change operation mode...", kSetModeSleep.count());
+  RCLCPP_INFO(
+    rclcpp::get_logger(
+      LINROB), "Waiting %ld seconds for PLC to change operation mode...", kSetModeSleep.count());
@@ -845 +848,4 @@
-      RCLCPP_INFO(rclcpp::get_logger(LINROB), "Axis has reached STANDSTILL state - enabling operations and switching to AUTO_EXTERNAL mode");
+      RCLCPP_INFO(
+        rclcpp::get_logger(
+          LINROB),
+        "Axis has reached STANDSTILL state - enabling operations and switching to AUTO_EXTERNAL mode");
@@ -855 +861,3 @@
-        RCLCPP_ERROR(rclcpp::get_logger(LINROB), "Failed to reset PLC buffer and index after axis became ready");
+        RCLCPP_ERROR(
+          rclcpp::get_logger(
+            LINROB), "Failed to reset PLC buffer and index after axis became ready");
@@ -864 +872,3 @@
-      RCLCPP_ERROR(rclcpp::get_logger(LINROB), "Axis is in ERROR state - operations will remain disabled");
+      RCLCPP_ERROR(
+        rclcpp::get_logger(
+          LINROB), "Axis is in ERROR state - operations will remain disabled");

Code style divergence in file 'src/axis_controller.cpp':

--- src/axis_controller.cpp
+++ src/axis_controller.cpp.uncrustify
@@ -6,2 +6,2 @@
-
-namespace {
+namespace
+{
@@ -10 +10,2 @@
-bool isServiceError(uint32_t error_code) {
+bool isServiceError(uint32_t error_code)
+{
@@ -13,4 +14,6 @@
-  return error_code != 0 && (strncmp(hex_code, "080F", 4) == 0 || strncmp(hex_code, "090F", 4) == 0);
-}
-
-std::string errorMessage(const char* action, uint32_t error_code) {
+  return error_code != 0 &&
+         (strncmp(hex_code, "080F", 4) == 0 || strncmp(hex_code, "090F", 4) == 0);
+}
+
+std::string errorMessage(const char * action, uint32_t error_code)
+{
@@ -24 +26,0 @@
-
@@ -64,2 +66,3 @@
-    std::bind(&AxisController::resetAxisService, this,
-              std::placeholders::_1, std::placeholders::_2));
+    std::bind(
+      &AxisController::resetAxisService, this,
+      std::placeholders::_1, std::placeholders::_2));
@@ -69,2 +72,3 @@
-    std::bind(&AxisController::referenceAxisService, this,
-              std::placeholders::_1, std::placeholders::_2));
+    std::bind(
+      &AxisController::referenceAxisService, this,
+      std::placeholders::_1, std::placeholders::_2));
@@ -74,2 +78,3 @@
-    std::bind(&AxisController::stopAxisService, this,
-              std::placeholders::_1, std::placeholders::_2));
+    std::bind(
+      &AxisController::stopAxisService, this,
+      std::placeholders::_1, std::placeholders::_2));
@@ -79,2 +84,3 @@
-    std::bind(&AxisController::startMotionService, this,
-              std::placeholders::_1, std::placeholders::_2));
+    std::bind(
+      &AxisController::startMotionService, this,
+      std::placeholders::_1, std::placeholders::_2));
@@ -194 +200 @@
-  const std::shared_ptr<linrob_axis::srv::ResetAxis::Request> /*request*/,
+  const std::shared_ptr<linrob_axis::srv::ResetAxis::Request>/*request*/,
@@ -213 +219 @@
-  const std::shared_ptr<linrob_axis::srv::ReferenceAxis::Request> /*request*/,
+  const std::shared_ptr<linrob_axis::srv::ReferenceAxis::Request>/*request*/,
@@ -232 +238 @@
-  const std::shared_ptr<linrob_axis::srv::StopAxis::Request> /*request*/,
+  const std::shared_ptr<linrob_axis::srv::StopAxis::Request>/*request*/,
@@ -254,2 +260,3 @@
-  RCLCPP_INFO(get_node()->get_logger(), "Start motion service called (start=%s, target=%f, velocity=%f)",
-              request->start ? "true" : "false", request->target_position, request->velocity);
+  RCLCPP_INFO(
+    get_node()->get_logger(), "Start motion service called (start=%s, target=%f, velocity=%f)",
+    request->start ? "true" : "false", request->target_position, request->velocity);

10 files with code style divergence


-- run_test.py: return code 1
-- run_test.py: verify result file '/home/boschrexroth/ctrlx-automation-sdk/samples-python/SNAP_ROS2/ros2_ws/src/linrob_axis/.obj-x86_64-linux-gnu/test_results/linrob_axis/uncrustify.xunit.xml'
